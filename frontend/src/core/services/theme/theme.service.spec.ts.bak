import { TestBed } from '@angular/core/testing';

import { ThemeService } from './theme.service';

describe('ThemeService', () => {
  let service: ThemeService;
  const STORAGE_KEY = 'hotel_theme';

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(ThemeService);
    // ensure document classList is clean before each test
    document.documentElement.classList.remove('theme--light', 'theme--dark');
    localStorage.removeItem(STORAGE_KEY);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  it('setTheme should update theme, write to localStorage and apply document class', () => {
    const setSpy = spyOn(localStorage, 'setItem');
    service.setTheme('dark');
    expect(service.getTheme()).toBe('dark');
    expect(service.isDarkMode()).toBeTrue();
    expect(setSpy).toHaveBeenCalledWith(STORAGE_KEY, 'dark');
    expect(document.documentElement.classList.contains('theme--dark')).toBeTrue();
  });

  it('toggleTheme should flip between light and dark', () => {
    service.setTheme('light');
    expect(service.getTheme()).toBe('light');
    service.toggleTheme();
    expect(service.getTheme()).toBe('dark');
    service.toggleTheme();
    expect(service.getTheme()).toBe('light');
  });

  it('init should read stored theme and apply it', () => {
    spyOn(localStorage, 'getItem').and.returnValue('dark');
    service.init();
    expect(service.getTheme()).toBe('dark');
    expect(document.documentElement.classList.contains('theme--dark')).toBeTrue();
  });

  it('init should fallback to prefers-color-scheme when no stored value', () => {
    // ensure no stored value
    spyOn(localStorage, 'getItem').and.returnValue(null);
    // stub matchMedia to indicate prefers dark
    const originalMatch = (window as any).matchMedia;
    (window as any).matchMedia = () => ({ matches: true }) as any;
    try {
      service.init();
      expect(service.getTheme()).toBe('dark');
      expect(document.documentElement.classList.contains('theme--dark')).toBeTrue();
    } finally {
      (window as any).matchMedia = originalMatch;
    }
  });
});
